OS/ALP PROGRAMS
OS PROGRAMS:
1. FCFS
PROGRAM:
#include <stdio.h>
int main() {
 int n, bt[100], wt[100], tat[100], avwt = 0, avtat = 0, i, j;
 printf("Enter total number of processes:");
 scanf("%d", &n);
 printf("\nEnter Process Burst Time\n");
 for (i = 0; i < n; i++) {
 printf("process %d:", i + 1);
 scanf("%d", &bt[i]);
 }
 wt[0] = 0;
 for (i = 1; i < n; i++) {
 wt[i] = 0;
 for (j = 0; j < i; j++)
 wt[i] += bt[j];
 }
 printf("\nProcess\t\tBurst Time\tWaiting Time\tTurnaround Time");
 for (i = 0; i < n; i++) {
 tat[i] = bt[i] + wt[i];
 avwt += wt[i];
 avtat += tat[i];
 printf("\nP%d\t\t%d\t\t%d\t\t%d", i + 1, bt[i], wt[i], tat[i]);
 }
 avwt /= i;
 avtat /= i;
 printf("\n\nAverage Waiting Time:%d", avwt);
 printf("\nAverage Turnaround Time:%d", avtat);
 return 0;
}
2. SJF
PROGRAM:
#include <stdio.h>
int main() {
 int bt[100], p[100], wt[100], tat[100], i, j, n, total = 0, pos, temp;
 float avg_wt, avg_tat;
 printf("Enter number of process:");
 scanf("%d", &n);
 printf("\nEnter Burst Time:\n");
 for (i = 0; i < n; i++) {
 printf("p%d:", i + 1);
 scanf("%d", &bt[i]);
 p[i] = i + 1;
 }
 for (i = 0; i < n; i++) {
 pos = i;
 for (j = i + 1; j < n; j++) {
 if (bt[j] < bt[pos])
 pos = j;
 }
 temp = bt[i];
 bt[i] = bt[pos];
 bt[pos] = temp;
 temp = p[i];
 p[i] = p[pos];
 p[pos] = temp;
 }
 wt[0] = 0;
 for (i = 1; i < n; i++) {
 wt[i] = 0;
 for (j = 0; j < i; j++)
 wt[i] += bt[j];
 total += wt[i];
 }
printf("\nProcess\tBurst Time\tWaiting Time\tTurnaround Time");
 for (i = 0; i < n; i++) {
 tat[i] = bt[i] + wt[i];
 total += tat[i];
 printf("\np%d\t\t %d\t\t %d\t\t%d", p[i], bt[i], wt[i], tat[i]);
 }
avg_wt = (float)total / n;
 total = 0;
 avg_tat = (float)total / n;
 printf("\n\nAverage Waiting Time=%f", avg_wt);
 printf("\nAverage Turnaround Time=%f\n", avg_tat);
}
3. PRIORITY
PROGRAM:
#include <stdio.h>
int main() {
 int bt[20], p[20], wt[20], tat[20], pr[20], i, j, n, total = 0, pos, temp,avg_wt, avg_tat;
 printf("Enter Total Number of Process:");
 scanf("%d", &n);
 printf("\nEnter Burst Time and Priority\n");
 for (i = 0; i < n; i++) {
 printf("\nP[%d]\n", i + 1);
 printf("Burst Time:");
 scanf("%d", &bt[i]);
 printf("Priority:");
 scanf("%d", &pr[i]);
 p[i] = i + 1;
 }
 for (i = 0; i < n; i++) {
 pos = i;
 for (j = i + 1; j < n; j++) {
 if (pr[j] < pr[pos])
 pos = j;
 }
 temp = pr[i];
 pr[i] = pr[pos];
 pr[pos] = temp;
 temp = bt[i];
 bt[i] = bt[pos];
 bt[pos] = temp;
 temp = p[i];
 p[i] = p[pos];
 p[pos] = temp;
 }
 wt[0] = 0;
 for (i = 1; i < n; i++) {
 wt[i] = 0;
 for (j = 0; j < i; j++)
 wt[i] += bt[j];
 total += wt[i];
 }
 avg_wt = total / n;
 total = 0;
 printf("\nProcess\tBurst Time\tWaiting Time\tTurnaround Time");
 for (i = 0; i < n; i++) {
 tat[i] = bt[i] + wt[i];
 total += tat[i];
 printf("\nP[%d]\t\t%d\t\t%d\t\t\t%d", p[i],bt[i], wt[i], tat[i]);
 }
 avg_tat = total / n;
 printf("\n\nAverage Waiting Time=%d", avg_wt);
 printf("\nAverage Turnaround Time=%d\n", avg_tat);
 return 0;
}
4. ROUND ROBIN
PROGRAM:
#include <stdio.h>
int main() {
 int i, limit, total = 0, x, counter = 0, time_quantum;
 int wt = 0, tat = 0, at[100], bt[100],
 temp[100];
 float avgwt, avgtat;
 printf("\nEnter Total Number of Processes:");
 scanf("%d", &limit);
 x = limit;
 for (i = 0; i < limit; i++) {
 printf("\nEnter Details of Process[%d]\n", i + 1);
 printf("Arrival Time:");
 scanf("%d", &at[i]);
 printf("Burst Time:");
 scanf("%d", &bt[i]);
 temp[i] = bt[i];
 }
 printf("\nEnter Time Quantum:");
 scanf("%d", &time_quantum);
 printf("\nProcess ID\t\tBurst Time\t Turnaround Time\t Waiting Time\n");
 for (total = 0, i = 0; x != 0;) {
 if (temp[i] <= time_quantum && temp[i] > 0) {
 total = total + temp[i];
 temp[i] = 0;
 counter = 1;
 } else if (temp[i] > 0) {
 temp[i] = temp[i] - time_quantum;
 total = total + time_quantum;
 }
 if (temp[i] == 0 && counter == 1) {
 x--;
 printf("\nProcess[%d]\t\t%d\t\t %d\t\t\t %d", i + 1, bt[i],total - at[i], total - at[i] - bt[i]);
 wt = wt + total - at[i] - bt[i];
 tat = tat + total - at[i];
 counter = 0;
 }
 if (i == limit - 1) {
 i = 0;
 } else if (at[i + 1] <= total) {
 i++;
 } else {
 i = 0;
 }
 }
 avg_wt = wt * 1.0 / lavgwt avgtat = tat * 1.0 / limit;
 printf("\n\nAverage Waiting Time:\t%f", avg_wt);
 printf("\nAvg Turnaround Time:\avgwt, avgtat);
 return 0;
}
5. MVT
PROGRAM:
#include <stdio.h>
int main() {
 int ms, mp[100], i, temp, n = 0;
 char ch = 'y';
 printf("\nEnter the total memory available: ");
 scanf("%d", &ms);
 temp = ms;
 for (i = 0; ch == 'y'; i++, n++) {
printf("\nEnter memory required for process %d: ", i + 1);
 scanf("%d", &mp[i]);
 if (mp[i] <= temp) {
printf("\nMemory is allocated for Process %d ", i + 1);
 temp = temp - mp[i];
 } else {
 printf("\nMemory is Full");
 break;
 }
 printf("\nDo you want to continue(y/n) -- ");
 scanf(" %c", &ch);
 }
 printf("\n\nTotal Memory Available: %d", ms);
 printf("\n\nPROCESS\t\t MEMORY ALLOCATED ");
 for (i = 0; i < n; i++)
 printf("\n %d\t\t%d", i + 1, mp[i]);
 printf("\n\nTotal Memory Allocated is %d", ms - temp);
 printf("\nTotal External Fragmentation is %d", temp);
}
6. LRU
PROGRAM:
#include <stdio.h>
int main() {
 int i, j, k, min, rs[25], m[10], count[10], flag[25], n, f, pf = 0, next = 1;
 printf("\nEnter the length of reference string : ");
 scanf("%d", &n);
 printf("\nEnter the reference string : ");
 for (i = 0; i < n; i++) {
 scanf("%d", &rs[i]);
 flag[i] = 0;
 }
 printf("\nEnter the number of frames : ");
 scanf("%d", &f);
 for (i = 0; i < f; i++) {
 count[i] = 0;
 m[i] = -1;
 }
 printf("\nThe Page Replacement process is \n");
 for (i = 0; i < n; i++) {
 for (j = 0; j < f; j++) {
 if (m[j] == rs[i]) {
 flag[i] = 1;
 count[j] = next;
 next++;
 }
 }
 if (flag[i] == 0) {
 if (i < f) {
 m[i] = rs[i];
 count[i] = next;
 next++;
 } else {
 min = 0;
 for (j = 1; j < f; j++)
 if (count[min] > count[j])
 min = j;
 m[min] = rs[i];
 count[min] = next;
 next++;
 }
 pf++;
 }
 for (j = 0; j < f; j++)
 printf("%d\t", m[j]);
 if (flag[i] == 0)
 printf("PF No. --> %d", pf);
 printf("\n");
 }
 printf("\nThe number of page faults using LRU are %d", pf);
 printf("\nTotal page hits=%d", n - pf);
}
7. OPTIMAL
PROGRAM:
#include <stdio.h>
int fr[3], n, m;
void display();
int main() {
 int i, j, page[20], fs[10];
 int max, found = 0, lg[3], index, k, l, flag1 = 0, flag2 = 0, pf = 0;
 float pr;
 printf("\nEnter length of the reference string : ");
 scanf("%d", &n);
 printf("\nEnter the reference string : ");
 for (i = 0; i < n; i++)
 scanf("%d", &page[i]);
 printf("\nEnter no of frames : ");
 scanf("%d", &m);
 for (i = 0; i < m; i++)
 fr[i] = -1;
 pf = m;
 for (j = 0; j < n; j++) {
 flag1 = 0;
 flag2 = 0;
 for (i = 0; i < m; i++) {
 if (fr[i] == page[j]) {
 flag1 = 1;
 flag2 = 1;
 break;
 }
 }
 if (flag1 == 0) {
 for (i = 0; i < m; i++) {
 if (fr[i] == -1) {
 fr[i] = page[j];
 flag2 = 1;
 break;
 }
 }
 }
 if (flag2 == 0) {
 for (i = 0; i < m; i++)
 lg[i] = 0;
 for (i = 0; i < m; i++) {
 for (k = j + 1; k <= n; k++) {
 if (fr[i] == page[k]) {
 lg[i] = k - j;
 break;
 }
 }
 }
 found = 0;
 for (i = 0; i < m; i++) {
 if (lg[i] == 0) {
 index = i;
 found = 1;
 break;
 }
 }
 if (found == 0) {
 max = lg[0];
 index = 0;
 for (i = 0; i < m; i++) {
 if (max < lg[i]) {
 max = lg[i];
 index = i;
 }
 }
 }
 fr[index] = page[j];
 pf++;
 }
 display();
 }
 printf("\nNumber of page faults : %d\n", pf);
 printf("Number of page hits : %d\n", n - pf);
 pr = (float)pf / n * 100;
 printf("Page fault rate = %f \n", pr);
}
void display() {
 int i;
 for (i = 0; i < m; i++)
 printf("%d\t", fr[i]);
 printf("\n");
}
8. SINGLE LEVEL DIRECTORY
PROGRAM:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
struct {
 char dname[10], fname[10][10];
 int fcnt;
} dir;
int main() {
 int i, ch;
 char f[30];
 dir.fcnt = 0;
 printf("\nEnter name of directory -- ");
 scanf("%s", dir.dname);
 while (1) {
 printf("\n\n1. Create File\n2. Delete File\n3. Search File \n4. Display Files\n5. Exit\nEnter
your choice :");
 scanf("%d", &ch);
 switch (ch) {
 case 1:
printf("\nEnter the name of the file ");
 scanf("%s", dir.fname[dir.fcnt]);
 dir.fcnt++;
 break;
 case 2:
 printf("\nEnter the name of the file");
 scanf("%s", f);
 for (i = 0; i < dir.fcnt; i++) {
 if (strcmp(f, dir.fname[i]) == 0) {
 printf("File %s is deleted ", f);
strcpy(dir.fname[i], dir.fname[dir.fcnt - 1]);
 break;
 }
 }
 if (i == dir.fcnt)
 printf("File %s not found", f);
 else
 dir.fcnt--;
 break;
 case 3:
 printf("\nEnter the name of the file -- ");
 scanf("%s", f);
 for (i = 0; i < dir.fcnt; i++) {
 if (strcmp(f, dir.fname[i]) == 0) {
 printf("File %s is found ", f);
 break;
 }
 }
 if (i == dir.fcnt)
 printf("File %s not found", f);
 break;
 case 4:
 if (dir.fcnt == 0)
 printf("\nDirectory Empty");
 else {
 printf("\n\tName of Directory is: %s \n\tThe Files are : ", dir.dname);
 for (i = 0; i < dir.fcnt; i++)
 printf("\n\t%s", dir.fname[i]);
 }
 break;
 default:
 exit(0);
 }
 }
}
9. TWO LEVEL DIRECTORY
PROGRAM:
#include<string.h>
#include<stdlib.h>
#include<stdio.h>
struct
{
char dname[10],fname[10][10];
int fcnt;
}dir[10];
void main()
{
int i,ch,dcnt,k;
char f[30], d[30];
dcnt=0;
while(1)
{
printf("\n\n1. Create Directory\t2. Create File\t3. Delete File");
printf("\n4. Search File\t\t5. Display\t6. Exit\tEnter your choice -- ");
scanf("%d",&ch);
switch(ch)
{
case 1: printf("\nEnter name of directory -- ");
scanf("%s", dir[dcnt].dname);
dir[dcnt].fcnt=0;
dcnt++;
printf("Directory created");
break;
case 2: printf("\nEnter name of the directory -- ");
scanf("%s",d);
for(i=0;i<dcnt;i++)
if(strcmp(d,dir[i].dname)==0)
{
printf("Enter name of the file -- ");
scanf("%s",dir[i].fname[dir[i].fcnt]);
printf("File created");
break;
}
if(i==dcnt)
printf("Directory %s not found",d);
break;
case 3: printf("\nEnter name of the directory -- ");
scanf("%s",d);
for(i=0;i<dcnt;i++)
{
if(strcmp(d,dir[i].dname)==0)
{
printf("Enter name of the file -- ");
scanf("%s",f);
for(k=0;k<dir[i].fcnt;k++)
{
if(strcmp(f, dir[i].fname[k])==0)
{
printf("File %s is deleted ",f);
dir[i].fcnt--;
strcpy(dir[i].fname[k],dir[i].fname[dir[i].fcnt]);
goto jmp;
}
}
printf("File %s not found",f);
goto jmp;
}
}
printf("Directory %s not found",d);
jmp : break;
case 4: printf("\nEnter name of the directory -- ");
scanf("%s",d);
for(i=0;i<dcnt;i++)
{
if(strcmp(d,dir[i].dname)==0)
{
printf("Enter the name of the file -- ");
scanf("%s",f);
for(k=0;k<dir[i].fcnt;k++)
{
if(strcmp(f, dir[i].fname[k])==0)
{
printf("File %s is found ",f);
goto jmp1;
}
}
printf("File %s not found",f);
goto jmp1;
}
}
printf("Directory %s not found",d);
jmp1: break;
case 5: if(dcnt==0)
printf("\nNo Directory's ");
else
{
printf("\nDirectory\tFiles");
for(i=0;i<dcnt;i++)
{
printf("\n%s\t\t",dir[i].dname);
for(k=0;k<dir[i].fcnt;k++)
printf("\t%s",dir[i].fname[k]);
}
}
break;
default:exit(0);
}
}
 }
10. HIERARCHIAL LEVEL DIRECTORY (DOESNâ€™T WORK)
PROGRAM:
#include<stdio.h>
#include<graphics.h>
struct tree_element
{
char name[20];
int x,y,ftype,lx,rx,nc,level;
struct tree_element *link[5];
};
typedef struct tree_element node;
int main()
{
int gd=DETECT,gm; node *root; root=NULL;
create(&root,0,"root",0,639,320);
 initgraph(&gd,&gm,"c:\\tc\\BGI");
 display(root);
closegraph();
}
create(node **root,int lev,char *dname,int lx,int rx,int x)
{
int i,gap;
 if(*root==NULL)
{
(*root)=(node *)malloc(sizeof(node));
 printf("Enter name of dir/file(under %s) :",dname);
 fflush(stdin);
gets((*root)->name);
printf("enter 1 for Dir/2 forfile :");
 scanf("%d",&(*root)->ftype);
 (*root)->level=lev;
(*root)->y=50+lev*50; (*root)->x=x;
(*root)->lx=lx; (*root)->rx=rx;
 for(i=0;i<5;i++)
(*root)->link[i]=NULL;
 if((*root)->ftype==1)
{
printf("No of sub directories/files(for %s):",(*root)->name);
 scanf("%d",&(*root)->nc);
 if((*root)->nc==0)
gap=rx-lx;
else gap=(rx-lx)/(*root)->nc;
 for(i=0;i<(*root)->nc;i++)
create(&((*root)->link[i]),lev+1,(*root)->name,lx+gap*i,lx+gap*i+gap,lx+gap*i+gap/2);
}
else (*root)->nc=0;
}
}
display(node *root)
{
int i; settextstyle(2,0,4);
 settextjustify(1,1);
 setfillstyle(1,BLUE);
setcolor(14); if(root!=NULL)
{
for(i=0;i<root->nc;i++)
{
line(root->x,root->y,root->link[i]->x,root->link[i]->y);
}
if(root->ftype==1)
 bar3d(root->x-20,root->y-10,root->x+20,root->y+10,0,0);
else
 fillellipse(root->x,root->y,20,20);
outtextxy(root->x,root->y,root->name); for(i=0;i<root->nc;i++)
{
 display(root->link[i]);
}
}
}
11. SEQUENTIAL FILE ALLOCATION
PROGRAM:
#include <stdio.h>
int main() {
 int f[50], i, st, len, j, c, k, count = 0;
 for (i = 0; i < 50; i++)
 f[i] = 0;
x:
 count = 0;
 printf("Enter starting block and length of files : ");
 scanf("%d%d", &st, &len);
 for (k = st; k < (st + len); k++)
 if (f[k] == 0)
 count++;
 if (len == count) {
 for (j = st; j < (st + len); j++)
 if (f[j] == 0) {
 f[j] = 1;
 printf("%d\t%d\n", j, f[j]);
 }
 if (j != (st + len - 1))
 printf("The file is allocated to disk\n");
 } else
 printf("The file is not allocated \n");
 printf("Do you want to enter more file(Yes - 1/No - 0)");
 scanf("%d", &c);
 if (c == 1)
 goto x;
 else
 exit(0);
}
12. LINKED FILE ALLOCATION
PROGRAM:
#include <stdio.h>
#include <stdlib.h>
int main() {
 int f[50], p, i, st, len, j, c, k, a;
 for (i = 0; i < 50; i++)
 f[i] = 0;
 printf("Enter how many blocks already allocated: ");
 scanf("%d", &p);
 printf("Enter blocks already allocated: ");
 for (i = 0; i < p; i++) {
 scanf("%d", &a);
 f[a] = 1;
 }
x:
 printf("Enter index starting block and length: ");
 scanf("%d%d", &st, &len);
 k = len;
 if (f[st] == 0) {
 for (j = st; j < (st + k); j++) {
 if (f[j] == 0) {
 f[j] = 1;
 printf("%d-------->%d\n", j, f[j]);
 } else {
 printf("%d Block is already allocated \n", j);
 k++;
 }
 }
 } else
 printf("%d starting block already allocated \n", st);
 printf("Do you want to enter more file(Yes - 1/No - 0)");
 scanf("%d", &c);
 if (c == 1)
 goto x;
 else
 exit(0); }
13. INDEXED FILE ALLOCATION
PROGRAM:
#include <stdio.h>
#include <stdlib.h>
int main() {
 int f[50], index[50],i,n,j, c, k, ind, count = 0;
 for (i = 0; i < 50; i++)
 f[i] = 0;
x:
 printf("Enter the index block: ");
 scanf("%d", &ind);
 if (f[ind] != 1) {
printf("Enter no.of block&files for the index %d on the disk : \n",ind);
 scanf("%d", &n);
 } else {
 printf("%d index is already allocated \n", ind);
 goto x;
 }
y:
 count = 0;
 for (i = 0; i < n; i++) {
 scanf("%d", &index[i]);
 if (f[index[i]] == 0)
 count++;
 }
 if (count == n) {
 for (j = 0; j < n; j++)
 f[index[j]] = 1;
 printf("Allocated\n");
 printf("File Indexed\n");
 for (k = 0; k < n; k++)
printf("%d-->%d : %d\n", ind, index[k], f[index[k]]);
 } else {
 printf("File in the index is already allocated \n");
 printf("Enter another file indexed");
 goto y;
 }
 printf("Do you want to enter more file(Yes - 1/No - 0)");
 scanf("%d", &c);
 if (c == 1)
 goto x;
 else
 exit(0);
}
ALP PROGRAMS:
1. PRINT CSE
CODE:
.MODEL SMALL
.STACK 100H
.DATA

STRING DB 'Computer Science and Engineering', '$'

.CODE
MAIN PROC FAR
MOV AX,@DATA
MOV DS,AX
LEA DX,STRING

MOV AH,09H
INT 21H

MOV AH,4CH
INT 21H

MAIN ENDP
END MAIN
2. DISPLAY MULTI STRINGS
CODE:
.MODEL SMALL
.STACK 100H
.DATA
MSG DB 'HELLO', 10, 13, 'WORLD!$'
.CODE
MAIN PROC
MOV AX, @data
MOV DS, AX
LEA DX,MSG
MOV AH,9
INT 21H
MOV AH,4Ch
INT 21H
MAIN ENDP
END MAIN
3. FACTORIAL
CODE:
ASSUME CS:CODE
CODE SEGMENT
START:
 MOV CX,5H
 MOV AX,1H
 NEXT:
 MUL CX
 DEC CX
 CMP CX,1H
 JNZ NEXT
 MOV AH,4CH
 MOV BL,AL
 MOV AL,0H
 INT 21H
CODE ENDS
END START
4. FIBONACCI
CODE:
ASSUME CS:CODE,DS:DATA
DATA SEGMENT
NL1 DB 10,'ENTER NUMBER:$'
NL2 DB 10,'$'
TEMP DB ?
DATA ENDS
CODE SEGMENT
START:
MOV AX,DATA
MOV DS,AX
LEA DX,NL1
MOV AH,09H
INT 21H
MOV AH,01H
INT 21H
SUB AL,30H
MOV CL,AL
MOV AL,0
MOV BL,1
LBL1:
MOV TEMP,AL
LEA DX,NL2
MOV AH,09H
INT 21H
ADD AX,3030H
MOV DX,AX
MOV AH,02H
INT 21H
MOV AL,TEMP
ADD AL,BL
MOV BL,TEMP
LOOP LBL1
MOV AH,4CH
INT 21H
CODE ENDS
END START
5. MAXIMUM OF 3 NUMBERS
CODE:
data segment
STRING1 DB 08h,14h,05h,0Fh,09h
res db ?
data ends
code segment
assume cs:code, ds:data
start: mov ax, data
mov ds, ax
mov cx, 04h
mov bl, 00h
LEA SI, STRING1
up:
mov al, [SI]
cmp al, bl
jl nxt
mov bl, al
nxt:
inc si
dec cx
jnz up
mov res,bl
int 3
code ends
end start
6. MAXIMUM AND MINIMUM
CODE:
ASSUME DS:DATA,CS:CODE
DATA SEGMENT
ARR DB 5,3,7,1,9,2,6,8,4
LEN DW $-ARR
MIN DB ?
MAX DB ?
DATA ENDS
CODE SEGMENT
START:
MOV AX,DATA
MOV DS,AX
LEA SI,ARR
MOV AL,ARR[SI]
MOV MIN,AL
MOV MAX,AL
MOV CX,LEN
REPEAT:
MOV AL,ARR[SI]
CMP MIN,AL
JL CHECKMAX
MOV MIN,AL
CHECKMAX:
CMP MAX,AL
JG DONE
MOV MAX,AL
DONE:
INC SI
LOOP REPEAT
MOV BL,MIN
MOV CL,MAX
MOV AH,4CH
INT 03H
CODE ENDS
END START
7. PRINT 0-9
CODE: .MODEL SMALL
.STACK 100H
.DATA
 PROMPT DB 'The counting from 0 to 9 is :
.CODE
 MAIN PROC
 MOV AX, @DATA
 MOV DS, AX
 LEA DX, PROMPT
 MOV AH, 9
 INT 21H
 MOV CX, 10
 MOV AH, 2
 MOV DL, 48
 @LOOP:
 INT 21H
 DEC CX
 JNZ @LOOP
 MOV AH, 4CH
 INT 21H
 MAIN ENDP
END MAIN
8. TRANSFER ONE TO ANOTHER
CODE:
org 100H
assume cs:code
code segment
start:
MOV Cx, 08H
MOV BX, 10H
MOV DX, 21H
mov si,bx
mov di,dx
mov al,cl
store:
mov byte ptr[si],al
dec al
cmp al,0h
jne store
again:
MOV Al, byte ptr[si]
MOV byte ptr[Di], Al
loop again
mov ah,4ch
int
code ends
end start
9. MINIMUM OF 3
CODE:
ASSUME CS: CODE DS:DATA
DATA SEGMENT
LIST DB 02H,01H,04H,03H
COUNT EQU 0003H
DATA ENDS
CODE SEGMENT
START:
MOV AX,DATA
MOV DS,AX
MOV AX,0000H
MOV CX,COUNT
MOV SI,OFFSET LIST
MOV AL,[SI]
AGAIN: CMP AL,[SI+1]
JL NEXT
MOV AL,[SI+1]
NEXT: INC SI
DEC CX
JNZ AGAIN
INT 03H
CODE ENDS
END START
