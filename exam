#include <stdio.h>
    #include <conio.h>
    #include <stdlib.h>
    int i,j,k,a,b,u,v,n,ne=1;
    int min,mincost=0,cost[9][9],parent[9];
    int find(int);
    int uni(int,int);
    void main()
    {
    	printf("\n\tImplementation of Kruskal's Algorithm\n");
    	printf("\nEnter the no. of vertices:");
    	scanf("%d",&n);
    	printf("\nEnter the cost adjacency matrix:\n");
    	for(i=1;i<=n;i++)
    	{
    	for(j=1;j<=n;j++)
    	{
    	scanf("%d",&cost[i][j]);
    	if(cost[i][j]==0)
    	cost[i][j]=999;
    	}
    	}printf("The edges of Minimum Cost Spanning Tree are\n");
    	while(ne < n)
    	{
    	for(i=1,min=999;i<=n;i++)
    	{
    	for(j=1;j <= n;j++)
    	{
    	if(cost[i][j] < min)
    	{
    	min=cost[i][j];
    	a=u=i;
    	b=v=j;
    	}
    	}
    	}
    	u=find(u);
    	v=find(v);
    	if(uni(u,v))
    	{
    	printf("%d edge (%d,%d) =%d\n",ne++,a,b,min);
    	mincost +=min;
    	}
    	cost[a][b]=cost[b][a]=999;
    	}
    	printf("\n\tMinimum cost = %d\n",mincost);
    	getch();
    }
    int find(int i)
    {
    	while(parent[i])
    	i=parent[i];
    	return i;
    }
    int uni(int i,int j)
    {
    	if(i!=j)
    	{
    	parent[j]=i;
    	return 1;
    	}
    	return 0;
    }
    
    
    
    
    
    
    
    
    
    #include <stdio.h>
#include <stdlib.h>

int main() {
    int v,i,j;
    scanf("%d",&v);
    int G[v][v],selected[v];
    for(i=0;i<v;i++){
        for(j=0;j<v;j++){
            scanf("%d",&G[i][j]);
        }
    }
    memset(selected,0,sizeof(selected));
    selected[0]=1;
    int x,y,noe=0,min,top=0;
    while(noe<v-1){
        min = 9999;
        x=0;
        y=0;
        for(i=0;i<v;i++){
            if(selected[i]){
                for(j=0;j<v;j++){
                    if(!selected[j] && G[i][j]){
                        if(min>G[i][j]){
                            min=G[i][j];
                            x=i;
                            y=j;
                        }
                    }
                }
            }   
        }
        selected[y]=1;
        top+=G[x][y];
        noe++;
    }
    printf("%d",top);
    
    return 0;
}






#include <stdio.h>
#include <limits.h>
#include <stdio.h>
int MatrixChainOrder(int p[], int i, int j)
{
   if (i == j)
   return 0;
   int k;
   int min = INT_MAX;
   int count;
   for (k = i; k < j; k++)
   {
  count = MatrixChainOrder(p, i, k)+ MatrixChainOrder(p, k + 1, j)+ p[i - 1] * p[k] * p[j];
      if (count < min)
      min = count;
	}
	return min;
}
int main()
{
	int arr[] = { 1, 2, 3, 4, 3 };
	int n = sizeof(arr) / sizeof(arr[0]);

	printf("Minimum number of multiplications is %d ",MatrixChainOrder(arr, 1, n - 1));
       return 0;
}







#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#define MIN(a, b) (a < b ? a : b)

typedef struct job_ {
	int id, deadline, profit;
}job;

int compare(const void *a, const void *b) { // descending
	return (((job *) a)->profit < ((job *) b)->profit);
}

void schedule(job data[], int n) {
	int i, j, check[n], ans = 0;
	memset(check, 0, sizeof(check));
	for (i = 0; i < n; i++) {
		for (j = MIN(data[i].deadline, n)-1; j >= 0; j--) {
			if (!check[j]) {
				check[j] = data[i].id;
				ans += data[i].profit;
				break;
			}
		}
	}
	printf("The sequence of job is: \n");
	for (i = 0; i < n; i++)
		if (check[i])
			printf("%d ", check[i]);
	printf("\nThe max profit is: %d\n", ans);
}

int main() {
	job data[10];
	int n, i, j;
	printf("Enter number of jobs:\n");
	scanf("%d", &n);
	printf("Enter jobs in the order (id deadline profit):\n");
	for (i = 0; i < n; i++)
		scanf("%d%d%d", &data[i].id, &data[i].deadline, &data[i].profit);
	qsort(data, n, sizeof(job), compare);
	schedule(data, n);
	return 0;
}
